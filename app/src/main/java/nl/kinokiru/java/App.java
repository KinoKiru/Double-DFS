/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package nl.kinokiru.java;

import java.util.ArrayList;

import nl.kinokiru.java.models.Board;
import nl.kinokiru.java.models.Color;
import nl.kinokiru.java.models.Place;

public class App {
    private Place pawn1;
    private Place pawn2;

    public static void main(String[] args) {
        Board board = new Board();
        App app = new App();
        app.pawn1 = board.board.get(0);
        app.pawn2 = board.board.get(1);

        System.out.println(app.dfs(app.pawn1));
    }

    public static int max = 0;

    // TODO removed argument visited.
    public ArrayList<Place> dfs(Place currentPawn) {
        // System.out.println(currentPawn);
        ArrayList<Place> resolvePath = new ArrayList<>();
        // so we don't get a stack overflow
        if (max++ > 20) {
            return resolvePath;
        }

        // is the last pawn en sets resolve path and then initiate
        // back track path
        if (currentPawn.getColor().equals(Color.BLUE)) {
            resolvePath.add(0, currentPawn);
            return resolvePath;
        }

        var places = currentPawn.getPlaces(getOtherPawn(currentPawn));
        // foreach place which is accessable loop
        for (Place newPawn : places) {
            Place oldPawn = currentPawn;
            // set the currentpawn to first place which is possible
            // ig: 1 -> 5 (pawn1, 5)
            updatePawn(oldPawn, newPawn);
            System.out.println(oldPawn + " -> " + newPawn);
            // if dfs returns resolve path sets it
            // also gives the updated place to the function
            resolvePath = dfs(newPawn);

            // if finish is found add the step at the start of path
            if (!resolvePath.isEmpty()) {
                resolvePath.add(0, newPawn);
                return resolvePath;
            }
            resolvePath = dfs(getOtherPawn(newPawn));
            // resolvePath = dfs(newPawn);
            // if the resolvePath still isn't found replace old place with currentplace
            updatePawn(newPawn, oldPawn);
            System.out.println(oldPawn + " <- " + newPawn);

        }
        return resolvePath;
    }

    /**
     * @param currentPawn
     * @return either pawn 1 or 2 if currentPawn is equals to pawn1
     */
    public Place getOtherPawn(Place currentPawn) {
        return currentPawn.equals(pawn1) ? pawn2 : pawn1;
    }

    // sets current pawn to new place
    public Place updatePawn(Place currentPawn, Place newPawn) {
        if (currentPawn.equals(pawn1)) {
            pawn1 = newPawn;
            return pawn1;
        } else {
            pawn2 = newPawn;
            return pawn2;
        }
    }

}

// public ArrayList<Place> olddfs(Place currentPawn) {
// ArrayList<Place> resolvePath = new ArrayList<>();

// if (max++ > 20) {
// return resolvePath;
// }

// if (currentPawn.getColor().equals(Color.BLUE)) {
// resolvePath.add(0, currentPawn);
// return resolvePath;
// }

// // if color is correct goes into for loop
// for (Place place : currentPawn.getPlaces(getOtherPawn(currentPawn))) {
// System.out.println(currentPawn + " <-old new-> " + place);
// updatePawn(currentPawn, place);
// resolvePath = dfs(place);

// if (!resolvePath.isEmpty()) {
// resolvePath.add(0, place);
// return resolvePath;
// } else {
// resolvePath = dfs(getOtherPawn(place));
// updatePawn(place, currentPawn);
// System.out.println(place + " <-old new-> " + currentPawn);
// if (!resolvePath.isEmpty()) {
// resolvePath.add(0, place);
// return resolvePath;
// }
// }

// }
// return resolvePath;
// }